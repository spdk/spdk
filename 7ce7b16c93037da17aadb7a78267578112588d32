{
  "comments": [
    {
      "key": {
        "uuid": "9129829f_3d8ba182",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2017-12-01T23:53:57Z",
      "side": 1,
      "message": "This should be broken up into shorter lines.\n\nCan you also describe a bit what you might use this for, and what context you might call it from?\n\nOne problem I see is that if this gets called from the context of the poller function, it will all crash, since we remove the poller from the requisite TAILQ (see reactor.c:440 and reactor.c:456).\n\nWould the following changes work for you and Fujitsu?\n1) Change function to spdk_poller_set_period().\n2) spdk_poller_set_period() fails if you go from 0 to \u003e0, or vice versa.  Meaning you can only change a timer that already had a period \u003e 0 to a different period \u003e 0.\n3) if the period is changed, the new period does not take effect until after the current timer period expires.",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0540dd9_99eef7c7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1011274
      },
      "writtenOn": "2017-12-04T18:24:51Z",
      "side": 1,
      "message": "\u003e This should be broken up into shorter lines.\n \u003e \n \u003e Can you also describe a bit what you might use this for, and what\n \u003e context you might call it from?\n \u003e \n\nIn our case, we want to convert the adminq_timer_poller from polling for an AEN to polling for pass_thru completion(s). Once we\u0027re done, we want to reset the timer back to the original AEN timer. Our specific use case is to significantly speed up the rpc call for nvme fw download, but it can also be used to make configuration changes while IO is suspended.\n\n \u003e One problem I see is that if this gets called from the context of\n \u003e the poller function, it will all crash, since we remove the poller\n \u003e from the requisite TAILQ (see reactor.c:440 and reactor.c:456).\n \u003e \n\nThat is why we make the modification as an event rather than in-line. This ensures that the modification is done outside the context of any poller. We can add an assert if poller-\u003estate \u003d\u003d SPDK_POLLER_STATE_RUNNING since this should never happen.\n\n \u003e Would the following changes work for you and Fujitsu?\n \u003e 1) Change function to spdk_poller_set_period().\n \u003e 2) spdk_poller_set_period() fails if you go from 0 to \u003e0, or vice\n \u003e versa.  Meaning you can only change a timer that already had a\n \u003e period \u003e 0 to a different period \u003e 0.\n \u003e 3) if the period is changed, the new period does not take effect\n \u003e until after the current timer period expires.\n\nThis would work for our fw download case since there are multiple adminq commands, but I am worried about the use case of a single adminq command with suspended IO. I think the current logic covers more use cases.",
      "parentUuid": "9129829f_3d8ba182",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "012c3601_9f3de0da",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2017-12-06T21:55:03Z",
      "side": 1,
      "message": "Thanks Paul - this really helps me understand why Fujitsu has submitted this patch.\n\nCan you explain a bit more what is meant by \"suspended IO\"?\n\nHere is another possibility - what if we had an RPC to create a second poller for the adminq?  You\u0027ll need to make sure it runs on the same thread as the AEN poller.  Then you could start this poller before submitting the FW download command and stop it once its done.  Then we don\u0027t have to muck with changing existing pollers.",
      "parentUuid": "c0540dd9_99eef7c7",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7dad44cf_f7931faa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1011274
      },
      "writtenOn": "2017-12-06T22:27:00Z",
      "side": 1,
      "message": "\u003e Thanks Paul - this really helps me understand why Fujitsu has\n \u003e submitted this patch.\n \u003e \n \u003e Can you explain a bit more what is meant by \"suspended IO\"?\n \u003e \n\nI was referring to some comments Ben made at the last meetup when we were discussing virtual controllers. He suggested suspending current IOs for virtual controllers if an adminq command was sent to the underlying physical controller that changed the configuration. You can check with Ben to see if this PR would be useful.\n\n \u003e Here is another possibility - what if we had an RPC to create a\n \u003e second poller for the adminq?  You\u0027ll need to make sure it runs on\n \u003e the same thread as the AEN poller.  Then you could start this\n \u003e poller before submitting the FW download command and stop it once\n \u003e its done.  Then we don\u0027t have to muck with changing existing\n \u003e pollers.\n\nIf Ben says he doesn\u0027t need this, then we can take a look at this approach.",
      "parentUuid": "012c3601_9f3de0da",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d94dbc33_412e8caf",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2017-12-01T23:53:57Z",
      "side": 1,
      "message": "I don\u0027t think we need to add this member.  We can always calculate this from period_ticks.",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fa85516_999c4cdc",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 1011274
      },
      "writtenOn": "2017-12-04T18:24:51Z",
      "side": 1,
      "message": "The purpose of this member is to save the original value so that it can restored. I don\u0027t think we can guarantee that spdk_get_ticks_hz() will always return the same value or be a multiple of period * ticks_per_us. Therefore, recalculation can result it a value slightly from the original.",
      "parentUuid": "d94dbc33_412e8caf",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5cd94eaf_10207758",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2017-12-06T21:55:03Z",
      "side": 1,
      "message": "SPDK already depends on invariant TSC for timers - we only store the number of ticks and use that to determine when a timer expires and where to put it in the list for rescheduling.\n\nIntel CPUs have had invariant TSC for a long time - are there other architectures that do not provide an invariant TSC?",
      "parentUuid": "9fa85516_999c4cdc",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91f2c828_2432f81e",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 1011274
      },
      "writtenOn": "2017-12-06T22:27:00Z",
      "side": 1,
      "message": "\u003e SPDK already depends on invariant TSC for timers - we only store\n \u003e the number of ticks and use that to determine when a timer expires\n \u003e and where to put it in the list for rescheduling.\n \u003e \n \u003e Intel CPUs have had invariant TSC for a long time - are there other\n \u003e architectures that do not provide an invariant TSC?\n\nYes, you are right about invariant TSC. But for some reason in our testing we sometimes saw an odd number from spdk_get_ticks_hz() which resulted in returning the original value minus 1 due to rounding from the division. It\u0027s not that big of a deal, so we can do the calculation if you want. Also, we wouldn\u0027t need this if we go with the second poller approach.",
      "parentUuid": "5cd94eaf_10207758",
      "revId": "7ce7b16c93037da17aadb7a78267578112588d32",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}