{
  "comments": [
    {
      "key": {
        "uuid": "94dc3796_5381e92c",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:13:57Z",
      "side": 1,
      "message": "I like the emphasis on modularity here and it\u0027s a good instinct. However, in this particular case where is never going to be any way to fill out these callbacks except by forwarding them to the nvme driver API. I am leaning toward just having this FTL make calls directly to the NVMe driver and eliminating these callbacks. I\u0027m open to other opinions.",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6b98e0c_6787e5e2",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1013988
      },
      "writtenOn": "2018-11-05T16:42:54Z",
      "side": 1,
      "message": "Yep, we intentionally created this callback\u0027s struct, having in mind extension module to the ftl.",
      "parentUuid": "94dc3796_5381e92c",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca9b6c2b_fcd743a9",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 197,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:51:31Z",
      "side": 1,
      "message": "Eliminate this callback structure and just pass these two parameters to the functions below.",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bad6116b_43080446",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 197,
      "author": {
        "id": 1013988
      },
      "writtenOn": "2018-11-05T16:42:54Z",
      "side": 1,
      "message": "Done, I have removed ocssd_cb from public API but it is convenient to use the structure internaly. Is it ok?",
      "parentUuid": "ca9b6c2b_fcd743a9",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e8388764_05fbd2e1",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 205,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:13:57Z",
      "side": 1,
      "message": "Please add doxygen comments describing these public API functions. We automatically generate API documentation and update https://spdk.io/doc accordingly.",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46bf9f7b_634fe71b",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 205,
      "author": {
        "id": 1013988
      },
      "writtenOn": "2018-11-05T16:42:54Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e8388764_05fbd2e1",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d02a8746_d49cc15c",
        "filename": "include/spdk/ocssd.h",
        "patchSetId": 2
      },
      "lineNbr": 216,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:51:31Z",
      "side": 1,
      "message": "Why not just do the ocssd_io_alloc automatically inside the read/write/flush functions?",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e54f6cef_3f3d3967",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:51:31Z",
      "side": 1,
      "message": "I am looking ahead at what these functions actually do and I think there is a design conflict we\u0027re going to need to work out. It seems that what you would like to write is software that spawns its own threads to be scheduled by the OS, and then you perform blocking (sleep) operations on that thread.\n\nThat, however, is not how SPDK works and it can be quite an adjustment to get used to the SPDK model, but I\u0027m confident we can make the FTL work how we need it to without ever spawning threads internally.\n\nSPDK is a collection of libraries intended to work as part of a cooperative multi-tasking framework. SPDK doesn\u0027t specify which framework is used (in the libraries themselves, at least) but it certainly assumes there is one. That means that all SPDK libraries should be passive - they only take action in response to direct function calls from a user. Further, the action they take should be well-bounded in time so they don\u0027t block other actions from occurring within the cooperative multi-tasking framework.\n\nThis FTL is certainly going to need to perform periodic garbage collection (reloc I think you call it in the code). However, instead of spawning a thread to go do that in the background, register a poller using spdk_poller_register.\n\nThis FTL also is going to have some major challenges with doing I/O in parallel from two different threads due to shared state. The I/O needs to get appended to the appropriate band in a thread-safe way. Today it appears that you are using these functions to message pass all of the I/O to a single thread per device. SPDK is very fast, and so that may not be the worst thing in the world, however I\u0027d like to really try to come up with a clever design that allows for truly parallel I/O in at least most cases.",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e00189ff_bcccb0cf",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-11-05T12:24:17Z",
      "side": 1,
      "message": "We were thinking about spdk_poller_register but this enforce user to use \"Application Framework\" with spdk_app_start. Some of existing applications (e.g. spdk/examples/bdev/fio_plugin) which don\u0027t support this model will not be able to use our library. Currently we are using fio_plugin as part of our functional tests.\n\nPeriodic garbage collection (reloc module is a part of it) is not the only task that needs to be run on separate thread/reactor. We have also separate (global) thread responsible for retrieving asynchronous media management events and dispatching them to the appropriate devices.\n\nAlso due to specific of open channel and NAND media itself we need to perform write operations with the specific restrictions. For instance we need to send erase command before we start writing to specific chunk and all blocks inside chunk needs to be written sequentially. We also grouping together chunks that are on the same position inside parallel unit (LUN) into band and we write some specific FTL metadata on bandâ€™s head and tail.\n\nWe also need to collect sufficient number of blocks from user before we sent them to the drive (there are minimal and optimal write size values returned from drive geometry which are multiple of 4K block size). This require from us maintaining write buffer (ocssd_rwb) to which we copy data from user. On the separate thread we are processing this buffer with constraints described above.\n\nWe will prepare documentation (as you suggested in previous comment) that describes more deeply our thread model and write/read path to discuss this concepts in more details.",
      "parentUuid": "e54f6cef_3f3d3967",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a2ca515_961d2217",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:51:31Z",
      "side": 1,
      "message": "SPDK has a great bitmap implementation you can use. See include/spdk/bit_array.h.",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8616b5f0_c296fae5",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-11-05T12:24:17Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "9a2ca515_961d2217",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f13c9f3f_f1a644de",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-11-05T13:24:36Z",
      "side": 1,
      "message": "I looked closely to bit array.h interface and it seems that it doesn\u0027t fit to our needs. We have use case where we need to serialize/deserialize one of our bitmaps to/from disk as a part of metadata and this interface dosen\u0027t support such operations directly.",
      "parentUuid": "8616b5f0_c296fae5",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88c6049a_219a39d7",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-11-01T22:51:31Z",
      "side": 1,
      "message": "SPDK_COUNTOF in include/spdk/util.h",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "679f12af_7717f851",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-11-05T12:24:17Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "88c6049a_219a39d7",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3967e7de_01c4a984",
        "filename": "lib/ocssd/ocssd_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-11-05T13:54:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "679f12af_7717f851",
      "revId": "7e6fc7f8a009d15d74732929719009baebc837dd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}