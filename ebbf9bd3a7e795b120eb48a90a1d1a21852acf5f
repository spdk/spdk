{
  "comments": [
    {
      "key": {
        "uuid": "b119fb9c_3f0e035c",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-15T08:45:14Z",
      "side": 1,
      "message": "Considering that spdk_nbd_start is asynchronous, I\u0027m wondering if this code is prone to any data races - e.g. when creating multiple nbd devices from a json config, one after another, so that multiple requests could be assigned to the same /dev/nbdX. \n\nPawel, do you have any insight? Is the above possible?",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac261752_662db427",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-01-15T11:45:14Z",
      "side": 1,
      "message": "Nice, I didnt knew about this PID file.\nBut yeah, I think this is prone to race. We are issuing many ioctls and pid file is created at last stage - the NBD_DO_IT ioctl.\n\nI will later post as steps I was thinking of. Stay tuned.",
      "parentUuid": "b119fb9c_3f0e035c",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9675e935_e8bb4013",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2019-01-15T15:09:56Z",
      "side": 1,
      "message": "Hi, Darek, yes, you\u0027ve pointed out the real pain spot.\nI tried, but failed to find out a widely acceptable way to prevent the nbd device races.\nWe can only make sure one nbd device is in using by the pid file. But we can\u0027t conclude that one nbd device is idle if no pid file.\n\nSo it\u0027s hard to prevent the races between different applications without extra pre-negotiated operations.\nFor the races inside one SPDK application like Darek\u0027s example, we can insert function spdk_nbd_disk_find_by_nbd_path inside function find_available_nbd_disk.\n\nWhat do you think about this way, Darek \u0026 Pawel?",
      "parentUuid": "ac261752_662db427",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39bc5d99_6c11147a",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-16T08:51:38Z",
      "side": 1,
      "message": "\u003e So it\u0027s hard to prevent the races between different applications without extra pre-negotiated operations.\n\nHow about brute force? We could try calling spdk_nbd_start for /dev/nbd0 and then in the completion callback retry with /dev/nbd(++i). After one callback completes successfully, it\u0027s 100% certain that we are an exclusive owner of the nbd device. After all, this is NBD - it doesn\u0027t have to be fast :)\n\nUsing spdk_nbd_disk_find_by_nbd_path also sounds fine.",
      "parentUuid": "9675e935_e8bb4013",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d0c63f7_ea50a923",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-01-16T11:58:42Z",
      "side": 1,
      "message": "@Darek you are always faster, but I\u0027m afraid it might not work.\n\nLooking at \u0027qemu-nbd -d\u0027 option it just doeas:\n\n  1. Open /dev/nbdX\n  2. ioctl(NBD_CLEAR_QUE) (this is NOP in nbd kernel module)\n  3. ioctl(NBD_DISCONNECT)\n  4. ioctl(NBD_CLEAR_SOCK)\n\nThis kills the nbd device. We basically do the same on nbd device creation so if brute force is used we might disconnect random device (first?) nbd device. Don\u0027t think we want this.\n\nI would try moving ioctl(NBD_SET_SOCK) before any other ioctl\u0027s we are doing in SPDK. The NBD_SET_SOCK seem to be only one reasonably guarded by locks in nbd kernel module.\n\nSo if NBD_SET_SOCK return\u0027s EBUSY somone else is owning this nbd device (the same is doing the `qemu-nbd -c` )",
      "parentUuid": "39bc5d99_6c11147a",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e47c431_e43df8e0",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-01-16T12:01:34Z",
      "side": 1,
      "message": "I forgot second part:\n\nWhen/if NBD_SET_SOCK will work then we can try brute force way iterating over all /dev/nbdX devices.",
      "parentUuid": "6d0c63f7_ea50a923",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}