{
  "comments": [
    {
      "key": {
        "uuid": "b119fb9c_3f0e035c",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-15T08:45:14Z",
      "side": 1,
      "message": "Considering that spdk_nbd_start is asynchronous, I\u0027m wondering if this code is prone to any data races - e.g. when creating multiple nbd devices from a json config, one after another, so that multiple requests could be assigned to the same /dev/nbdX. \n\nPawel, do you have any insight? Is the above possible?",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac261752_662db427",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-01-15T11:45:14Z",
      "side": 1,
      "message": "Nice, I didnt knew about this PID file.\nBut yeah, I think this is prone to race. We are issuing many ioctls and pid file is created at last stage - the NBD_DO_IT ioctl.\n\nI will later post as steps I was thinking of. Stay tuned.",
      "parentUuid": "b119fb9c_3f0e035c",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9675e935_e8bb4013",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2019-01-15T15:09:56Z",
      "side": 1,
      "message": "Hi, Darek, yes, you\u0027ve pointed out the real pain spot.\nI tried, but failed to find out a widely acceptable way to prevent the nbd device races.\nWe can only make sure one nbd device is in using by the pid file. But we can\u0027t conclude that one nbd device is idle if no pid file.\n\nSo it\u0027s hard to prevent the races between different applications without extra pre-negotiated operations.\nFor the races inside one SPDK application like Darek\u0027s example, we can insert function spdk_nbd_disk_find_by_nbd_path inside function find_available_nbd_disk.\n\nWhat do you think about this way, Darek \u0026 Pawel?",
      "parentUuid": "ac261752_662db427",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39bc5d99_6c11147a",
        "filename": "lib/nbd/nbd_rpc.c",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-16T08:51:38Z",
      "side": 1,
      "message": "\u003e So it\u0027s hard to prevent the races between different applications without extra pre-negotiated operations.\n\nHow about brute force? We could try calling spdk_nbd_start for /dev/nbd0 and then in the completion callback retry with /dev/nbd(++i). After one callback completes successfully, it\u0027s 100% certain that we are an exclusive owner of the nbd device. After all, this is NBD - it doesn\u0027t have to be fast :)\n\nUsing spdk_nbd_disk_find_by_nbd_path also sounds fine.",
      "parentUuid": "9675e935_e8bb4013",
      "revId": "ebbf9bd3a7e795b120eb48a90a1d1a21852acf5f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}