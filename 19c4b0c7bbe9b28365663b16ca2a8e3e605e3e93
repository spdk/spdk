{
  "comments": [
    {
      "key": {
        "uuid": "21e09f65_c7e9edf8",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:13:32Z",
      "side": 1,
      "message": "Does NetApp have a use case for populate (and commit)?  I guess I don\u0027t follow where we will use this.  If it\u0027s truly zero copy, then the data should always be populated and will be directly committing anything it writes.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e82f0ac9_e43ff49b",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-06-21T16:10:03Z",
      "side": 1,
      "message": "This is tricky. There are a few considerations when implementing a bdev module that supports this zcopy interface. For the simplest bdev modules, like the malloc bdev example I show in the next patch in the series, each block is represented by a fixed region in memory. In that case, zcopy start can return a pointer directly to the backing memory and the user can memcpy into and out of the region. Populate and commit do nothing in this scenario.\n\nThere are a few other designs that want to support zcopy though. For example, the malloc bdev, using the strategy I\u0027m currently employing, isn\u0027t able to provide any atomicity guarantees. If it was instead implemented as a linked list of block-sized buffers with some associated LBA to buffer mapping, then on a zcopy start a new buffer could be obtained, optionally populated with the live data, and passed to the user, and then the updates only made \"live\" on zcopy_end when commit is set to true. That is still zero copy on commit at least because the commit just updates metadata. This design also allows for stronger atomicity guarantees. It so happens that this is how the pmem bdev module works - it never writes in place.\n\nThere are other designs that cache data in memory. In these cases, if the data the user is requesting is not already in cache, populating it may be an expensive operation. If the user intends to overwrite the data entirely with new data, it can skip that step. Similarly on zcopy_end, if the user only read from the buffer, it does not need to go through the work of making the data persistent (which may require flushing to disk).",
      "parentUuid": "21e09f65_c7e9edf8",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "940b3c43_5348e233",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1838,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2018-06-21T00:02:25Z",
      "side": 1,
      "message": "I could be reading this wrong, but couldn\u0027t you technically use this zero copy operation to get a read only buffer? For example, if populate was true, this would simply return the values inside the blocks, then you could filter out the condition if (!desc-\u003ewrite \u0026\u0026 commit).",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a147960_56d29076",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1838,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "But the bdev layer can\u0027t enforce how the caller will use the buffer that is returned.  So we can only use the zcopy API on write-enabled descriptors.",
      "parentUuid": "940b3c43_5348e233",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8679c5a4_ae52eb57",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1848,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "duing \u003d\u003e during\nwritev \u003d\u003e zcopy_start\n\nBut really I think we should remove this ERRLOG altogether - I removed them as part of the recent spdk_bdev_queue_io_wait patch.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c54eef92_e977fb6f",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1884,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "Same here.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}