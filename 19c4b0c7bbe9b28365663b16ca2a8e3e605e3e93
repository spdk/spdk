{
  "comments": [
    {
      "key": {
        "uuid": "9c104ff2_9bec36eb",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1014259
      },
      "writtenOn": "2018-06-21T19:49:54Z",
      "side": 1,
      "message": "We will need to expand on ZOPY_START and ZCOPY_END to indicate if this is a READ or a WRITE operation. The semantics are quite different when it comes to READ-START and WRITE-START. Similarly, the ZCOPY-END for READ and WRITE are different.\nCan I suggest that we either add IO type within zcopy union or expand these ENUMS.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa01c4d5_989d3d0b",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-22T01:10:10Z",
      "side": 1,
      "message": "For read, zcopy_start would be called with populate \u003d\u003d true.  This means that the bdev module must make sure the allocated buffer point to memory that has been populated with the backing blocks.\n\nFor write, zcopy_end would be called with commit \u003d true.  This means that the bdev module must commit the allocated buffer to the backing blocks.",
      "parentUuid": "9c104ff2_9bec36eb",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21e09f65_c7e9edf8",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:13:32Z",
      "side": 1,
      "message": "Does NetApp have a use case for populate (and commit)?  I guess I don\u0027t follow where we will use this.  If it\u0027s truly zero copy, then the data should always be populated and will be directly committing anything it writes.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e82f0ac9_e43ff49b",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-06-21T16:10:03Z",
      "side": 1,
      "message": "This is tricky. There are a few considerations when implementing a bdev module that supports this zcopy interface. For the simplest bdev modules, like the malloc bdev example I show in the next patch in the series, each block is represented by a fixed region in memory. In that case, zcopy start can return a pointer directly to the backing memory and the user can memcpy into and out of the region. Populate and commit do nothing in this scenario.\n\nThere are a few other designs that want to support zcopy though. For example, the malloc bdev, using the strategy I\u0027m currently employing, isn\u0027t able to provide any atomicity guarantees. If it was instead implemented as a linked list of block-sized buffers with some associated LBA to buffer mapping, then on a zcopy start a new buffer could be obtained, optionally populated with the live data, and passed to the user, and then the updates only made \"live\" on zcopy_end when commit is set to true. That is still zero copy on commit at least because the commit just updates metadata. This design also allows for stronger atomicity guarantees. It so happens that this is how the pmem bdev module works - it never writes in place.\n\nThere are other designs that cache data in memory. In these cases, if the data the user is requesting is not already in cache, populating it may be an expensive operation. If the user intends to overwrite the data entirely with new data, it can skip that step. Similarly on zcopy_end, if the user only read from the buffer, it does not need to go through the work of making the data persistent (which may require flushing to disk).",
      "parentUuid": "21e09f65_c7e9edf8",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "13314fec_03564228",
        "filename": "include/spdk/bdev.h",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1014259
      },
      "writtenOn": "2018-06-21T19:49:54Z",
      "side": 1,
      "message": "I think I understand Ben\u0027s intent of Populate vs Commit. Netapp will be using Commit where as malloc will be using populate. Similarly pmem when modified to acquire in place buffers will use commit. Is that correct?",
      "parentUuid": "e82f0ac9_e43ff49b",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "940b3c43_5348e233",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1838,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2018-06-21T00:02:25Z",
      "side": 1,
      "message": "I could be reading this wrong, but couldn\u0027t you technically use this zero copy operation to get a read only buffer? For example, if populate was true, this would simply return the values inside the blocks, then you could filter out the condition if (!desc-\u003ewrite \u0026\u0026 commit).",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a147960_56d29076",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1838,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "But the bdev layer can\u0027t enforce how the caller will use the buffer that is returned.  So we can only use the zcopy API on write-enabled descriptors.",
      "parentUuid": "940b3c43_5348e233",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8679c5a4_ae52eb57",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1848,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "duing \u003d\u003e during\nwritev \u003d\u003e zcopy_start\n\nBut really I think we should remove this ERRLOG altogether - I removed them as part of the recent spdk_bdev_queue_io_wait patch.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c1878d7_8bd97183",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1882,
      "author": {
        "id": 1014259
      },
      "writtenOn": "2018-06-22T03:26:27Z",
      "side": 1,
      "message": "We should be using the bdev_io that was obtained in zcopy_start phase. This is because bdev_io will have the data buffer context necessary to release the allocated buffer.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3facbe0e_a9245679",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1882,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-22T15:58:48Z",
      "side": 1,
      "message": "I think Ben was thinking of making some changes to this effect.  Where zcopy_end would take the zcopy_start bdev_io as a parameter.",
      "parentUuid": "3c1878d7_8bd97183",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c54eef92_e977fb6f",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1884,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-21T00:05:16Z",
      "side": 1,
      "message": "Same here.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c37733fa_b01189a0",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1895,
      "author": {
        "id": 1014259
      },
      "writtenOn": "2018-06-21T20:41:50Z",
      "side": 1,
      "message": "The callback can become overloaded and is a function of success of failure of this submission. In other words, if data buffer allocation fails, then the callback should free the bdev_io and return DATA_BUFFER_PENDING to transport for retry. If success, I\u0027m guessing this bdev_io is reused and submit_io is directly called. or Do you anticipate that we create a new bdev_io in each submission leg.\n\nIf latter, then it kind of introduces few error paths where in REQUEST abort can leave data buffer unreleased as the context is stored only in the bdevio.",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d0c487e_b44163dd",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 3
      },
      "lineNbr": 1895,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-22T01:10:10Z",
      "side": 1,
      "message": "I think if the bdev module fails some kind of internal data buffer allocation, then it is responsible for queueing until a buffer becomes available.  Otherwise I\u0027m not sure when the retry would happen?",
      "parentUuid": "c37733fa_b01189a0",
      "revId": "19c4b0c7bbe9b28365663b16ca2a8e3e605e3e93",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}