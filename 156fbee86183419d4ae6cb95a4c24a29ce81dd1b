{
  "comments": [
    {
      "key": {
        "uuid": "b06de2f9_bb218add",
        "filename": "module/bdev/crypto/vbdev_crypto.c",
        "patchSetId": 6
      },
      "lineNbr": 309,
      "author": {
        "id": 1012251
      },
      "writtenOn": "2019-12-15T01:31:11Z",
      "side": 1,
      "message": "Substituting the head pointer to a temporary variable may be simpler\n\nTAILQ_HEAD(device_qps, device_qp) g_device_qp_qat;\nTAILQ_HEAD(device_qps, device_qp) g_device_qp_aesni_mb;\n\nTAILQ_HEAD(device_qps, device_qp) *head;\n\nif (strcmp(device-\u003ecdb_info.driver_name, QAT) \u003d\u003d 0) {\n  head \u003d \u0026g_device_qp_qat;\n} else {\n  head \u003d \u0026g_device_qp_aesni_mb;\n}\n\nfor (j \u003d 0; j \u003c device-\u003ecdev_info.max_nb_queue_pairs; j++) {\n  dev_qp \u003d calloc();\n  TAILQ_INSERT_TAIL(head, dev_qp, link);\n}",
      "revId": "156fbee86183419d4ae6cb95a4c24a29ce81dd1b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57a7c7c4_5019f122",
        "filename": "module/bdev/crypto/vbdev_crypto.c",
        "patchSetId": 6
      },
      "lineNbr": 309,
      "author": {
        "id": 1011289
      },
      "writtenOn": "2019-12-16T16:36:24Z",
      "side": 1,
      "message": "So I don\u0027t think I can reuse the same struct name for these 2 lists, when I do I get \n\nvbdev_crypto.c:75:12: error: redefinition of ‘struct device_qps’\n TAILQ_HEAD(device_qps, device_qp) g_device_qp_aesni_mb \u003d TAILQ_HEAD_INITIALIZER(g_device_qp_aesni_mb);\n            ^\nvbdev_crypto.c:74:12: note: originally defined here\n TAILQ_HEAD(device_qps, device_qp) g_device_qp_qat \u003d TAILQ_HEAD_INITIALIZER(g_device_qp_qat);\n            ^",
      "parentUuid": "b06de2f9_bb218add",
      "revId": "156fbee86183419d4ae6cb95a4c24a29ce81dd1b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49b171f8_2a8ee41f",
        "filename": "module/bdev/crypto/vbdev_crypto.c",
        "patchSetId": 6
      },
      "lineNbr": 309,
      "author": {
        "id": 1012251
      },
      "writtenOn": "2019-12-16T22:17:20Z",
      "side": 1,
      "message": "Sorry for my wrong information. Name of head was not necessary.\n\n--- a/module/bdev/crypto/vbdev_crypto.c\n+++ b/module/bdev/crypto/vbdev_crypto.c\n@@ -221,6 +221,7 @@ create_vbdev_dev(uint8_t index, uint16_t num_lcores)\n        uint8_t j, cdev_id, cdrv_id;\n        struct device_qp *dev_qp;\n        struct device_qp *tmp_qp;\n+       TAILQ_HEAD(, device_qp) *tmp_qps;\n        int rc;\n\n        device \u003d calloc(1, sizeof(struct vbdev_dev));\n@@ -233,6 +234,15 @@ create_vbdev_dev(uint8_t index, uint16_t num_lcores)\n        cdrv_id \u003d device-\u003ecdev_info.driver_id;\n        cdev_id \u003d device-\u003ecdev_id \u003d index;\n\n+       if ((device-\u003ecdev_info.driver_name, QAT) \u003d\u003d 0) {\n+               tmp_qps \u003d \u0026g_device_qp_qat;\n+       } else if (strcmp(device-\u003ecdev_info.driver_name, AESNI_MB) \u003d\u003d 0) {\n+               tmp_qps \u003d \u0026g_device_qp_aesni_mb;\n+       } else {\n+               free(device);\n+               return -EINVAL;\n+       }\n+\n        /* Before going any further, make sure we have enough resources for this\n         * device type to function.  We need a unique queue pair per core accross each\n         * device type to remain lockless....\n@@ -306,15 +316,7 @@ create_vbdev_dev(uint8_t index, uint16_t num_lcores)\n                dev_qp-\u003edevice \u003d device;\n                dev_qp-\u003eqp \u003d j;\n                dev_qp-\u003ein_use \u003d false;\n-               if (strcmp(device-\u003ecdev_info.driver_name, QAT) \u003d\u003d 0) {\n-                       TAILQ_INSERT_TAIL(\u0026g_device_qp_qat, dev_qp, link);\n-               } else if (strcmp(device-\u003ecdev_info.driver_name, AESNI_MB) \u003d\u003d 0) {\n-                       TAILQ_INSERT_TAIL(\u0026g_device_qp_aesni_mb, dev_qp, link);\n-               } else {\n-                       rc \u003d -EINVAL;\n-                       free(dev_qp);\n-                       goto err;\n-               }\n+               TAILQ_INSERT_TAIL(tmp_qps, dev_qp, link);\n        }\n\n        /* Add to our list of available crypto devices. */\n@@ -322,12 +324,8 @@ create_vbdev_dev(uint8_t index, uint16_t num_lcores)\n\n        return 0;\n err:\n-       TAILQ_FOREACH_SAFE(dev_qp, \u0026g_device_qp_qat, link, tmp_qp) {\n-               TAILQ_REMOVE(\u0026g_device_qp_qat, dev_qp, link);\n-               free(dev_qp);\n-       }\n-       TAILQ_FOREACH_SAFE(dev_qp, \u0026g_device_qp_aesni_mb, link, tmp_qp) {\n-               TAILQ_REMOVE(\u0026g_device_qp_aesni_mb, dev_qp, link);\n+       TAILQ_FOREACH_SAFE(dev_qp, tmp_qps, link, tmp_qp) {\n+               TAILQ_REMOVE(tmp_qps, dev_qp, link);\n                free(dev_qp);\n        }\n        free(device);\n@@ -1248,27 +1246,27 @@ crypto_bdev_ch_create_cb(void *io_device, void *ctx_buf)\n        struct crypto_io_channel *crypto_ch \u003d ctx_buf;\n        struct vbdev_crypto *crypto_bdev \u003d io_device;\n        struct device_qp *device_qp;\n+       TAILQ_HEAD(, device_qp) *tmp_qps \u003d NULL;\n\n        crypto_ch-\u003ebase_ch \u003d spdk_bdev_get_io_channel(crypto_bdev-\u003ebase_desc);\n        crypto_ch-\u003epoller \u003d spdk_poller_register(crypto_dev_poller, crypto_ch, 0);\n        crypto_ch-\u003edevice_qp \u003d NULL;\n\n-       pthread_mutex_lock(\u0026g_device_qp_lock);\n        if (strcmp(crypto_bdev-\u003edrv_name, QAT) \u003d\u003d 0) {\n-               TAILQ_FOREACH(device_qp, \u0026g_device_qp_qat, link) {\n-                       if (device_qp-\u003ein_use \u003d\u003d false) {\n-                               crypto_ch-\u003edevice_qp \u003d device_qp;\n-                               device_qp-\u003ein_use \u003d true;\n-                               break;\n-                       }\n-               }\n+               tmp_qps \u003d \u0026g_device_qp_qat;\n        } else if (strcmp(crypto_bdev-\u003edrv_name, AESNI_MB) \u003d\u003d 0) {\n-               TAILQ_FOREACH(device_qp, \u0026g_device_qp_aesni_mb, link) {\n-                       if (device_qp-\u003ein_use \u003d\u003d false) {\n-                               crypto_ch-\u003edevice_qp \u003d device_qp;\n-                               device_qp-\u003ein_use \u003d true;\n-                               break;\n-                       }\n+               tmp_qps \u003d \u0026g_device_qp_aesni_mb;\n+       } else {\n+               assert(false);\n+               return -EINVAL;\n+       }\n+\n+       pthread_mutex_lock(\u0026g_device_qp_lock);\n+       TAILQ_FOREACH(device_qp, tmp_qps, link) {\n+               if (device_qp-\u003ein_use \u003d\u003d false) {\n+                       crypto_ch-\u003edevice_qp \u003d device_qp;\n+                       device_qp-\u003ein_use \u003d true;\n+                       break;\n                }\n        }\n        pthread_mutex_unlock(\u0026g_device_qp_lock);",
      "parentUuid": "57a7c7c4_5019f122",
      "revId": "156fbee86183419d4ae6cb95a4c24a29ce81dd1b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0125fbf2_4d45f5b9",
        "filename": "module/bdev/crypto/vbdev_crypto.c",
        "patchSetId": 6
      },
      "lineNbr": 325,
      "author": {
        "id": 1012251
      },
      "writtenOn": "2019-12-15T01:31:11Z",
      "side": 1,
      "message": "We can use cached head pointer here too.",
      "revId": "156fbee86183419d4ae6cb95a4c24a29ce81dd1b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}