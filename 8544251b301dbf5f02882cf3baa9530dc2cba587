{
  "comments": [
    {
      "key": {
        "uuid": "c7067c1a_22034553",
        "filename": "examples/nvme/perf/perf.c",
        "patchSetId": 1
      },
      "lineNbr": 602,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2017-08-21T17:09:38Z",
      "side": 1,
      "message": "Hi Lance,\n\nCould this code get put into probe_cb instead?  Then you could just set the default io_queue_requests (like we do already for io_queue_size).",
      "revId": "8544251b301dbf5f02882cf3baa9530dc2cba587",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7877fdee_977af02a",
        "filename": "examples/nvme/perf/perf.c",
        "patchSetId": 1
      },
      "lineNbr": 602,
      "author": {
        "id": 1011995
      },
      "writtenOn": "2017-08-21T19:43:30Z",
      "side": 1,
      "message": "At this point of the driver initialization, neither ctrlr-\u003emax_xfer_size nor ns-\u003esectors_per_stripe have been set.  That happens after the return from the probe callback.  So, the probe callback would not have those parameters to consider if it elected to attempt calculating io_queue_requests.",
      "parentUuid": "c7067c1a_22034553",
      "revId": "8544251b301dbf5f02882cf3baa9530dc2cba587",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3481bcd_3e7a2f31",
        "filename": "examples/nvme/perf/perf.c",
        "patchSetId": 1
      },
      "lineNbr": 615,
      "author": {
        "id": 1011995
      },
      "writtenOn": "2017-08-21T16:12:18Z",
      "side": 1,
      "message": "The reason for adding one for io_queue_requests beyond the queue size covers the case when (previously) the number of io requests equaled the io queue size.  In that scenario, when perf launches the io queue depth number of I/Os initially and first calls the completion API, the driver completion path invokes the callback BEFORE free\u0027ing up the corresponding I/O request entry.  As such, for this corner case, there\u0027d be no available I/O request entry and so the new I/O submitted in perf\u0027s callback would fail.  Allocating a entry request (or requests (plural) for the case of multiple cmd\u0027s for an I/O exceeding the max xfer size), we avoid that scenario.",
      "revId": "8544251b301dbf5f02882cf3baa9530dc2cba587",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}