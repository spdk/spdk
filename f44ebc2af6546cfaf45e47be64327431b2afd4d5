{
  "comments": [
    {
      "key": {
        "uuid": "784bad59_c4b52b22",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 6
      },
      "lineNbr": 874,
      "author": {
        "id": 1011207
      },
      "writtenOn": "2018-06-11T09:54:13Z",
      "side": 1,
      "message": "As NVMe can be passed through, need to take care specially here. Tested with Malloc and NVMe SSD backend, it works both.",
      "range": {
        "startLine": 874,
        "startChar": 0,
        "endLine": 874,
        "endChar": 30
      },
      "revId": "f44ebc2af6546cfaf45e47be64327431b2afd4d5",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c129ead_fe4da230",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 6
      },
      "lineNbr": 874,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-06-11T21:39:44Z",
      "side": 1,
      "message": "Good catch.\n\nNow that I look at this again, it might be better to explicitly list just the I/O types that have meaningful num_blocks as well.  For example, SPDK_BDEV_IO_TYPE_RESET doesn\u0027t set num_blocks, and FLUSH should probably not be counted as taking disk bandwidth. (I\u0027m not sure if we want to count UNMAP either.)\n\nSomething like:\n\n    switch (bdev_io-\u003etype) {\n    case SPDK_BDEV_IO_TYPE_NVME_...:\n        return bdev_io-\u003eu.nvme_passthru.nbytes;\n    case SPDK_BDEV_IO_TYPE_READ:\n    case SPDK_BDEV_IO_TYPE_WRITE:\n        return bdev_io-\u003eu.bdev.num_blocks * bdev-\u003eblocklen;\n    default:\n        return 0;\n    }",
      "parentUuid": "784bad59_c4b52b22",
      "range": {
        "startLine": 874,
        "startChar": 0,
        "endLine": 874,
        "endChar": 30
      },
      "revId": "f44ebc2af6546cfaf45e47be64327431b2afd4d5",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39d1d9fa_66f7ad5a",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 6
      },
      "lineNbr": 874,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-06-11T21:40:46Z",
      "side": 1,
      "message": "(WRITE_ZEROES should probably also be counted along with READ and WRITE; I didn\u0027t mean to leave that out of my list above.)",
      "parentUuid": "1c129ead_fe4da230",
      "range": {
        "startLine": 874,
        "startChar": 0,
        "endLine": 874,
        "endChar": 30
      },
      "revId": "f44ebc2af6546cfaf45e47be64327431b2afd4d5",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cdb9d72_5293305b",
        "filename": "lib/bdev/bdev.c",
        "patchSetId": 6
      },
      "lineNbr": 874,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-06-11T23:42:22Z",
      "side": 1,
      "message": "I could potentially see cases for including and not including UNMAP.  But if I had to pick one, I would say that we should count UNMAP - I think it is fairly similar to WRITE and WRITE_ZEROES.  It can definitely impact performance of other clients using the same underlying device.",
      "parentUuid": "39d1d9fa_66f7ad5a",
      "range": {
        "startLine": 874,
        "startChar": 0,
        "endLine": 874,
        "endChar": 30
      },
      "revId": "f44ebc2af6546cfaf45e47be64327431b2afd4d5",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}