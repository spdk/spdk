{
  "comments": [
    {
      "key": {
        "uuid": "22059bf1_8a1d9167",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 299,
      "author": {
        "id": 1011207
      },
      "writtenOn": "2018-05-30T05:49:34Z",
      "side": 1,
      "message": "May submit a separate patch to remove this _SAFE() as here there is no remove operation on the list. Others looks like fine. Thanks.",
      "range": {
        "startLine": 299,
        "startChar": 14,
        "endLine": 299,
        "endChar": 19
      },
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "573a51ea_df043f5f",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 299,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-05-30T17:34:28Z",
      "side": 1,
      "message": "I think the _SAFE is used since the remove_cb could detach the controller and remove it from the list.",
      "parentUuid": "22059bf1_8a1d9167",
      "range": {
        "startLine": 299,
        "startChar": 14,
        "endLine": 299,
        "endChar": 19
      },
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7e07d56_7d03c5f2",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 301,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-05-30T16:48:06Z",
      "side": 1,
      "message": "I\u0027m not sure I understand the logic behind this fix.  Is there something inside this block using the current process pointer without checking it?\n\nThe crash from bug #313 is inside spdk_nvme_ctrlr_get_regs_csts(), which doesn\u0027t seem to use the current process pointer.",
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c713f0cb_dfc1630a",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 301,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-05-30T17:34:28Z",
      "side": 1,
      "message": "I agree.  I believe that it fixes your issue, but it\u0027s not clear why.",
      "parentUuid": "b7e07d56_7d03c5f2",
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0c21e0d_171428e5",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 301,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-05-30T17:57:41Z",
      "side": 1,
      "message": "Maybe this should be taking the ctrlr lock (in addition to the driver lock, which we already hold); it seems like this could be a race between a process setting up the regs pointer and another process accessing it, although I\u0027m not sure how this could happen, since the regs pointer should already be set up and valid before inserting the controller into the shared_attached_ctrlrs list.  We should also be careful about lock ordering - I don\u0027t know if we ever take driver_lock and  ctrlr_lock simultaneously anywhere else, but if we do, we need to make sure it\u0027s in a consistent order to avoid deadlock.",
      "parentUuid": "c713f0cb_dfc1630a",
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef14287a_6ce96008",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 301,
      "author": {
        "id": 1011373
      },
      "writtenOn": "2018-06-01T00:46:43Z",
      "side": 1,
      "message": "Actually I think my solution is a workaround. I just know that spdk_nvme_ctrlr_get_regs_csts caused core dump while the ctrlr don\u0027t have current process in its active_procs list. So I add these if to let the function only access the ctrlr which have current process.\n\nHi Daniel,\nYou mean I need to add ctrlr lock codes into this if lines? Or choose ctrlr lock method to fix this issue?\n\nThanks\n\nLiang",
      "parentUuid": "b0c21e0d_171428e5",
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb4100b4_b3b23eb3",
        "filename": "lib/nvme/nvme_pcie.c",
        "patchSetId": 2
      },
      "lineNbr": 301,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-06-05T21:44:04Z",
      "side": 1,
      "message": "I meant that locking the ctrlr_lock mutex around the check below might be the fix, e.g.:\n\n  nvme_robust_mutex_lock(\u0026ctrlr-\u003ectrlr_lock);\n  // operate on ctrlr\n  nvme_robust_mutex_unlock(\u0026ctrlr-\u003ectrlr_lock);\n\nHowever, this needs to be carefully checked to make sure we never take the ctrlr_lock and driver lock in the other order (to avoid deadlocks).",
      "parentUuid": "ef14287a_6ce96008",
      "revId": "d8d2cb7dfb8551696d11e2d8c6a8a3e3d4522e82",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}