{
  "comments": [
    {
      "key": {
        "uuid": "c266fc11_b5b4257c",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1384,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "Is there really a 1:1 correspondence between the number of sgl descriptors and the number of required work requests? What if the sgl descriptor describes a region of memory larger than 8k?\n\nI think you need to take a different approach to implementing spdk_nvmf_rdma_request_fill_iovs_multi_sgl where you just have one top level loop over the descriptors and you grab both work requests and data buffers out of the pools one by one as you need them. We\u0027ll end up hammering the spdk_mempool_get function in the first implementation, but I think ultimately we\u0027ll want to cache the wrs per thread like we do with the data buffers anyway.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "231b9748_d9c2c0e7",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1384,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "If the sgl descriptor references a memory region larger than 8k, then we use the scatter gather list inside of the wr object. The 1-1 correspondence between a work request and an sgl descriptor will always hold for the following reasons.\n1. Each sgl descriptor can only describe a single contiguous region of memory.\n2. Each wr has an ibv_sge large enough to handle the maximum I/O size (This is necessary from the single sgl case).\n\nThere is a pretty serious performance problem with allocating either buffers or work requests one by one. Say we are processing an I/O with 16 SGL descriptors that needs 16 buffers (this could be a 128k I/O with 8k segments). When we process that I/O we could do 15 iterations of pulling buffers and requests off of the mempool and then realize we don\u0027t have a 16th buffer available. IF we were provisioning one by one, then we would have to unwind the whole I/O, put everything back and try again later. This whole process is really really expensive. There would also be no guarantee that we would have enough resources next time we tried.\nI have measured this and it tanks performance at high queue depths. That is why I added this patch https://review.gerrithub.io/c/spdk/spdk/+/440765/22",
      "parentUuid": "c266fc11_b5b4257c",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32a89ed9_20947626",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1501,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "Can you rename \u0027inline_sgl\u0027 to \u0027inline_segment\u0027? Trying to follow the exact terms used in the spec. You could also consider \u0027inline_desc\u0027 too - the inline SGL segment always contains exactly 1 descriptor, so for this particular case they are interchangeable pointers.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01a6a5cf_7d48b7ba",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1501,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "32a89ed9_20947626",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06326cab_17e3a1c8",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1509,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "I think in theory num_sgl_descriptors could be 1. This would be a stupid way to send an I/O that only has 1 data buffer, but I do think it\u0027s valid. I\u0027m not sure what happens inside nvmf_request_fill_data here if you tell it to get you 0 wrs from the pool.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "164935a9_dc32aaaa",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1509,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "In the event that num_sgl_descriptors is zero, we don\u0027t allocate anything from the pool, we use the data struct embedded in the rdma_req. (i.e. current_wr \u003d \u0026rdma_req-\u003edata.wr). That case works very similarly to the original fill_iovs function.",
      "parentUuid": "06326cab_17e3a1c8",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc3b7cae_eff54480",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1510,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "This nvmf_request_fill_data function is just grabbing a set of wrs up front - it\u0027s not filling the data buffers in at all. I think the name is really confusing. I think the name was probably derived from filling in the \"request_data\" structures, but I feel like that\u0027s gotten lost. Something like alloc_wrs would be better.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e7f932b_db912dab",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1510,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bc3b7cae_eff54480",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8654efb2_372de502",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1518,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "Instead of using cmd_sgl_segment[ui] throughout the loop, can you store a variable called segment that points to this region (line 1506) and then at the top of the loop, set a pointer to a \"desc\" correctly for the current iteration? Then you can use \"desc\" everywhere, which I think is both shorter and closer to the language used in the spec.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e15975c_4efc778a",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1518,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8654efb2_372de502",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef84b47e_235454c1",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1519,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "Put a comment here that the only allowed descriptor type in this location is a KEYED_DATA_BLOCK. Also, does the subtype need to be a specific type? Should you check that here?",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be7ae9b_16edbc94",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1519,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ef84b47e_235454c1",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5fa2ce3e_7235834f",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1523,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "remaining_desc_length I think is better - the spec calls each element of an SGL a descriptor.",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba3f0e34_057eaf84",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1523,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5fa2ce3e_7235834f",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "12d4cba0_f27ca305",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1527,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-03-21T23:16:10Z",
      "side": 1,
      "message": "Is this little section that grabs a data buffer something we could break out into an inline static function? Is this used anywhere else?",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5f1eb5b_8ac7a411",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 69
      },
      "lineNbr": 1527,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-03-25T23:21:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "12d4cba0_f27ca305",
      "revId": "fe6fad7fd2735c598a5d6c8d6eb8b3bbbbf244ec",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}