{
  "comments": [
    {
      "key": {
        "uuid": "cec3e8c0_97683ac5",
        "filename": "lib/ftl/ftl_reloc.c",
        "patchSetId": 31
      },
      "lineNbr": 530,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-12-19T16:55:36Z",
      "side": 1,
      "message": "I missed this earlier.  This is a variable sized array on the stack.  It\u0027s technically allowed in C, but I\u0027d prefer to not have it in SPDK.\n\nYou can just pick some value here (16?) and then dequeue in stages into this sized array.",
      "revId": "c787211abe1b219f17602810e4dc7bf8adac970f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04f1796f_602807c5",
        "filename": "lib/ftl/ftl_reloc.c",
        "patchSetId": 31
      },
      "lineNbr": 530,
      "author": {
        "id": 1015344
      },
      "writtenOn": "2018-12-20T09:35:29Z",
      "side": 1,
      "message": "Dequeue in stages may result in unwanted behaviour when we are trying to do relocate write (similar pattern is in ftl_reloc_process_queue()). In case when the write buffer is full we get EAGAIN error we put this IO again to write_queue. Dequeue in statges may result in unnecessary processing such request. I will remove this variable sized array and allocate this buffer on heap.",
      "parentUuid": "cec3e8c0_97683ac5",
      "revId": "c787211abe1b219f17602810e4dc7bf8adac970f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b5849037_8a360569",
        "filename": "lib/ftl/ftl_reloc.c",
        "patchSetId": 31
      },
      "lineNbr": 530,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-12-20T15:28:29Z",
      "side": 1,
      "message": "Sorry - I did not mean that you should only do one batch and then return from the function.  I meant something more like this:\n\nstruct ftl_io *io[16];\nsize_t qdepth_remaining;\n\nqdepth_remaining \u003d reloc-\u003emax_qdepth;\nwhile (qdepth_remaining \u003e 0) {\n  num_ios \u003d spdk_ring_dequeue(..., (void **)io, SPDK_COUNTOF(io));\n  for (I \u003d 0; I \u003c num_ios; ++i) {\n    ftl_io_free(io[i]);\n  }\n  if (num_ios \u003c SPDK_COUNTOF(io)) {\n    break;\n  }\n  qdepth_remaining -\u003d num_ios;\n}\n\nOr maybe this can be even simpler, and just keep dequeuing up to 16 at a time until there are no more entries in the ring.",
      "parentUuid": "04f1796f_602807c5",
      "revId": "c787211abe1b219f17602810e4dc7bf8adac970f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}