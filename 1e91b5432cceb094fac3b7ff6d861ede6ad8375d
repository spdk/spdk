{
  "comments": [
    {
      "key": {
        "uuid": "e88cbb41_e43e434d",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "I don\u0027t think the general_counter is going to end up being useful in tests and it\u0027s adding quite a bit of complexity. I\u0027d recommend you remove the general one.",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a527bcc3_2e247f6f",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "I think we still need general one, because w/o it we won\u0027t catch some flows where we could trigger power failure. Let me explain on below example. We have flow where we have such operations in this particular order (but it is not obvious when looking at the code):\n\nread\nread\nread\nwrite\nwrite\nread\nread\nwrite\n\nWith general counter, we set to fail after 4th IO operation, and test will fail after 1st write. With read and write counters we set both to fail after 4th operation of its kind. With that the fail will be after 4th read and we won\u0027t catch errors paths between 1st write and 4th read. In such case we can test that error paths, but we will have to get the read/write flow before writing the test, to get know which values to set to read threshold and write threshold. It will also succeed on last write, which is not fully power failure scenario. \n\nSo the only easy way to make sure that power failure will be triggered at particular \"time\" is to use general counter. The other counters are here to simulate some other cases than power failure (like only write errors, where read is still working).",
      "parentUuid": "e88cbb41_e43e434d",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8430538_e02111d6",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-06-03T19:23:00Z",
      "side": 1,
      "message": "I\u0027m not sure I\u0027m following along entirely. When you\u0027re writing a test, you\u0027re testing for a specific thing typically. For example, you could be testing that the writes that occur during deleting a snapshot are atomic with regard to power loss. In that case, you only care about failing writes. Certainly, you could write a different test that was checking that failed reads worked correctly on this code path, but that doesn\u0027t have anything to do with power loss and is a different test that\u0027s probably full of a different set of CU_ASSERTs. In fact, failed reads will never be necessary on power failure tests at all, but you can leave that functionality in because it\u0027s probably useful for writing tests that catch disk failures.\n\nI just don\u0027t currently see a single test that you could write that wouldn\u0027t care whether it was the reads or the writes failing. I think you always should care because it affects the observed behavior (i.e. the CU_ASSERTs you write) so dramatically. Because of that, you\u0027d never end up using the general trigger.",
      "parentUuid": "a527bcc3_2e247f6f",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1787475_c1daa0c8",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-04T12:55:48Z",
      "side": 1,
      "message": "I\u0027m getting what are you saying, but still w/o general trigger we won\u0027t be able to hit some error paths easily. Let me show different example. Sample algorithm:\n\ncb_function4(errno)\n{\n    if (errno) {\n        ....                 // error path 3\n    }\n\n    ....\n}\n\ncb_function3(errno)\n{\n    if (errno) {\n        ....                 // error path 2\n    }\n\n    ....\n    function4(cb_function4)  //function4 performs only 2 reads\n}\n\ncb_function2(errno)\n{\n    if (errno) {\n        ....                 // error path 1\n    }\n\n    ....\n    function3(cb_function3)  //function3 performs only 2 writes\n}\n\nfunction1(errno)\n{\n    ....\n    function2(cb_function2)  //function2 performs only 2 reads\n}\n\n\nIf we will set to trigger on Nth number of read and run it in loop with N++ we will hit only error path 1 and 3. If we do the same thing with setting trigger to Nth write we will only hit error path 2. So for testing whole algorithm we have to write two separate loops/tests and both of them will test same functionality but with different simulated failures underneath. With general trigger and I can test each of the error path in above algorithm with only one loop/test (like in the next patch in series).\n\nIt all depends what aspect of the test we want to test - writes/reads/error paths. In next patch in series I want to test the case, where we loose power / fail at each stage of the delete operation no matter if it is a read or write and check if we recover from that correctly after power is back (writes failures) and also if error path won\u0027t crush/segfault/etc in case of failure (reads failures). This is where general trigger helps me to make this test simpler.",
      "parentUuid": "a8430538_e02111d6",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b4edb65_ab8477a8",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "static",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8af84d6_affd6e25",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6b4edb65_ab8477a8",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9a58b99_e0ad4168",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 64,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "static",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc70bd33_4a92be7c",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 64,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c9a58b99_e0ad4168",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff6079af_24ea0cba",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 66,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "static",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a92d2036_efcacdf6",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 66,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ff6079af_24ea0cba",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4e8d9023_904eaa4b",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 68,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "No need for forward declarations",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d80ffd0_3f6f698f",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 68,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "See comment below.",
      "parentUuid": "4e8d9023_904eaa4b",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a040d27_9081c93f",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 70,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "Extra whitespace",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a384779_9169f7a4",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 70,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6a040d27_9081c93f",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cbaf4302_584be6b4",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 72,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "Is this supposed to reset everything? How do you just reset the counters?\n\nI think this shouldn\u0027t zero out g_power_failure_thresholds. If the user wants to change the thresholds they can call the function below.",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b8d143e_6daf3fed",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 72,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "This will be used to disable power failure after one iteration of test ended (see next patch in series). I would need to call 2 functions (with your suggestion) to disable it. I can add another function that would only reset counters, but wouldn\u0027t disable power failure mechanism (won\u0027t clear threshold) - something like dev_reset_power_failure_counters(). What do you think?",
      "parentUuid": "cbaf4302_584be6b4",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fddf7c9b_fef9048b",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 73,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T17:04:22Z",
      "side": 1,
      "message": "static",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d0f6ed2_262d22fa",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 73,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "It would trigger \"unused\" warning. Even in the next patch where it is used, because it is also included in blobfs_async_ut.c but not used there.",
      "parentUuid": "fddf7c9b_fef9048b",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cede797f_b01176a8",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T16:46:35Z",
      "side": 1,
      "message": "call this dev_set_power_failure_thresholds",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7f6f6625_33464aa8",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cede797f_b01176a8",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "74813adc_9fd3afa0",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-05-31T17:04:22Z",
      "side": 1,
      "message": "static",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3fad6ca0_c158c79f",
        "filename": "test/unit/lib/blob/bs_dev_common.c",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 1011262
      },
      "writtenOn": "2019-06-03T08:20:39Z",
      "side": 1,
      "message": "See previous comment.",
      "parentUuid": "74813adc_9fd3afa0",
      "revId": "1e91b5432cceb094fac3b7ff6d861ede6ad8375d",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}