{
  "comments": [
    {
      "key": {
        "uuid": "81b1ede0_0223fe8d",
        "filename": "include/spdk/nvme_msg.h",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-07-11T01:25:55Z",
      "side": 1,
      "message": "I still do not know why we need two separate IO rpc types.  Xiaodong - could you give an example?\n\nI don\u0027t see where NVME_IO_CMD would get processed in the next file.  It looks like the code right now only handles NVME_IO_RAW_CMD.\n\nI know that the Linux kernel has IOCTL_SUBMIT_IO and IOCTL_IO_CMD - but I find that really confusing.  We should avoid multiple IO RPCs if we can avoid it I think.  But please provide the example since there\u0027s probably something I\u0027m not understanding.\n\nThanks.",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf2f7b9e_af5805be",
        "filename": "include/spdk/nvme_msg.h",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2018-07-11T02:40:19Z",
      "side": 1,
      "message": "Yes, Jim. The naming of IOCTL_SUBMIT_IO and IOCTL_IO_CMD is really very confusing.\nfrom my understanding:\n\nIOCTL_IO_CMD means that this is one io-passthrough command, most elements of its nvme-cmd structure is formatted by nvme-cli.\nIts corresponding data could be handled by prp in one nvme command.\neg: nvme io-passthru /dev/nvme0 --opcode\u003d0x02 --namespace-id\u003d0x1 --data-len\u003d512 --read --cdw10\u003d0 --cdw11\u003d0 --cdw12\u003d0 -b \u003e lba.0.io\nBackend like SPDK bdev, could directly call spdk_bdev_nvme_io_passthru or spdk_nvme_ctrlr_cmd_io_raw to process the command.\n\nIOCTL_SUBMIT_IO means nvme-cli only passes its requriments to the backend. And let backend to format some nvme commands.\neg: \"nvme read /dev/nvme0n1 --start-block\u003d0 --block-count\u003d0 --data-size\u003d51200 --data\u003dlba.0.read\"\nBackend like SPDK bdev, could directly call spdk_bdev_read/write or spdk_nvme_ns_cmd_read/write to process the command.\n\nBesides the difference that who is the author of nvme command, one accessary difference is that\nIOCTL_SUBMIT_IO could read/write large length of data, since the backend will help split the data into several nvme commands.\nbut if IOCTL_IO_CMD read/write large length, data that exceeds one nvme command\u0027s capacity will be ignored.",
      "parentUuid": "81b1ede0_0223fe8d",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a820899_1720ac6d",
        "filename": "include/spdk/nvme_msg.h",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2018-07-11T03:05:00Z",
      "side": 1,
      "message": "Of course, we can combine IOCTL_SUBMIT_IO into IOCTL_IO_CMD. but this require the client side to split data and format commands, which means we need to add such logicals into nvme rpc client library.\nHowever, it looks like a duplication with part of our nvme driver.",
      "parentUuid": "bf2f7b9e_af5805be",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "753d7c82_a9c50b4f",
        "filename": "lib/bdev/nvme/nvme_rpc.c",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-07-11T01:25:55Z",
      "side": 1,
      "message": "should use /* */ style comments (I\u0027m not exactly sure what the comment is referring to though)",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8292e905_e0709d47",
        "filename": "lib/bdev/nvme/nvme_rpc.c",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2018-07-11T03:05:00Z",
      "side": 1,
      "message": "Sorry for the lack of description.\nHere it means, in the subsequent patches, function types of io_cmd_func and dev_list_func should be considered and updated. since current definitions are too simple to use.\n\nio_cmd_func will be used to process NVME_IO_CMD(IOCTL_SUBMIT_IO).\ndev_list_func will be used by one rpc like get_nvme_devices to list nvme devices.\n\nJust want to modify subsequent patches after reaching an agreement at this patch, in order to avoid stepping into wrong direction.",
      "parentUuid": "753d7c82_a9c50b4f",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "11e0371d_ae236653",
        "filename": "lib/bdev/nvme/nvme_rpc.c",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2018-07-11T01:25:55Z",
      "side": 1,
      "message": "I don\u0027t think data_len and metdata_len are needed for h2c.  We can just infer it from the length of data and metadata.\n\nFor c2h, this structure is not used.",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f57a8f08_0bcc03ac",
        "filename": "lib/bdev/nvme/nvme_rpc.c",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 1011712
      },
      "writtenOn": "2018-07-11T01:56:51Z",
      "side": 1,
      "message": "For c2h, explicit \"data_len\"\"metadata_len\" are used.\nSince based on previous talk, we will not extract the length information from nvme cmdbuf, but directly show them outside to simplify the transfer and parse work.\n\nFor h2c, we can just infer them from the transferred length of data and metadata.\nBut for c2h, it is not necessary for rpc request to transfer data and metadata. But the SPDK side should know these required lengths in order to realize how much data should be sent back.",
      "parentUuid": "11e0371d_ae236653",
      "revId": "c686ec0d8e0d92ccf517c88841d6e864dc5e8fbe",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}