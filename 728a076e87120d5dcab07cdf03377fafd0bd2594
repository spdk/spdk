{
  "comments": [
    {
      "key": {
        "uuid": "f6037771_0d51fc27",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1114,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-04-16T19:18:17Z",
      "side": 1,
      "message": "This path was depending on the destruct_namespace to work correctly.",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce9d2f67_d42f8319",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1118,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-04-16T18:20:46Z",
      "side": 1,
      "message": "realloc doesn\u0027t guarantee that the newly allocated memory is zeroed out. You\u0027ll need to do that by memsetting the new region, if nn is larger than ctrlr-\u003enum_ns.\n\nYou should also handle the case where nn \u003c ctrlr-\u003enum_ns by destroying any namespaces that used to exist but no longer do.",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4fbc52c_e8936277",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1118,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-04-16T19:18:17Z",
      "side": 1,
      "message": "I don\u0027t see how this change makes any sense - realloc can always return a different pointer than the original, so the old process of \"destroy + alloc\" accomplishes the same task and is simpler anyway.",
      "parentUuid": "ce9d2f67_d42f8319",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dabacbe8_fcd9f03f",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1118,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2018-04-17T01:27:18Z",
      "side": 1,
      "message": "I want to make function \"nvme_ctrlr_construct_namespaces\" can be reused at the re-scan namespace job, but according to you following comments, I think even we don\u0027t destruct namespaces first, this function may be still unsafe for callers.",
      "parentUuid": "e4fbc52c_e8936277",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3bcdd525_ed3fef0e",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1118,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2018-04-17T01:27:18Z",
      "side": 1,
      "message": "yes, should take this into consideration.",
      "parentUuid": "ce9d2f67_d42f8319",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb5502d5_d9b9a042",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1186,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-04-16T19:18:17Z",
      "side": 1,
      "message": "I don\u0027t think it\u0027s safe to call this here - the only time it\u0027s safe to resize the ns array is during controller init (when the user doesn\u0027t have access to ctrlr yet) and during reset (where the user is explicitly warned that namespace pointers may be invalidated).  If the user wants to rescan namespaces, they can register an AER callback and do it themselves when they know that all namespace pointers are possibly going to be invalidated (we can provide some kind of namespace rescan API to do that rather than requiring a full reset).",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3fd7ca65_ec653287",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1186,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2018-04-17T01:27:18Z",
      "side": 1,
      "message": "Here SPDK can just scan the changed namespace, then it\u0027s safe to those unchanged namespaces.",
      "parentUuid": "cb5502d5_d9b9a042",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5321bf54_b05a1e73",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1186,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-04-17T15:55:45Z",
      "side": 1,
      "message": "Yes, I think it should be safe to just update the nsdata for the existing namespaces (NSIDs 1-NN), because the controller isn\u0027t allowed to change NN at runtime.  Maybe we can split nvme_ctrlr_construct_namespaces() into two parts, one that resizes the array, and one that just updates the nsdata.",
      "parentUuid": "3fd7ca65_ec653287",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba9b2da3_75fc8c1a",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1186,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2018-04-18T09:13:03Z",
      "side": 1,
      "message": "NVMf target may change NN during runtime, I think it spdk_nvme_ns inside NVMe controller structure should use link list or static array instead of malloc it from memory. Then the upper layer such as bdev_nvme module, don\u0027t need to get the unchanged namespace again.",
      "parentUuid": "5321bf54_b05a1e73",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78fd75b4_650910df",
        "filename": "lib/nvme/nvme_ctrlr.c",
        "patchSetId": 1
      },
      "lineNbr": 1186,
      "author": {
        "id": 1010525
      },
      "writtenOn": "2018-04-18T22:55:23Z",
      "side": 1,
      "message": "The target definitely should not be changing NN during runtime while a controller exists; if it does, that\u0027s a bug and should be fixed.  The list of which namespaces are active within the 1..NN range can change, but the actual NN limit should not change within the lifetime of a controller, even when features like Namespace Management are supported.\n\nI think we can simplify this patch to split out the part of nvme_ctrlr_construct_namespaces() starting with the call to nvme_ctrlr_identify_active_ns() into its own function (nvme_ctrlr_update_namespaces() or something like that) and only call that on NS attr changed events.  Then we still need to add some way to notify upper layers that namespaces may have changed (so that e.g. the bdev layer can be updated, as you mentioned).",
      "parentUuid": "ba9b2da3_75fc8c1a",
      "revId": "728a076e87120d5dcab07cdf03377fafd0bd2594",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}