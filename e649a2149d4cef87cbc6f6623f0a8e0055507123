{
  "comments": [
    {
      "key": {
        "uuid": "afe4a9b5_a9f82cee",
        "filename": "lib/nvme/nvme_transport.c",
        "patchSetId": 20
      },
      "lineNbr": 299,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2020-01-10T08:13:17Z",
      "side": 1,
      "message": "This call is used in IO path and the current implementation of nvme_get_transport() which iterates the list of transports and compares strings will most likely reduce performance. Probably we can store a pointer to transport inside of controller? I believe that this pointer won\u0027t be changed during life time of the controller",
      "range": {
        "startLine": 299,
        "startChar": 13,
        "endLine": 299,
        "endChar": 61
      },
      "revId": "e649a2149d4cef87cbc6f6623f0a8e0055507123",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73158e34_b5269da7",
        "filename": "lib/nvme/nvme_transport.c",
        "patchSetId": 20
      },
      "lineNbr": 299,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2020-01-10T16:41:43Z",
      "side": 1,
      "message": "Sadly I can\u0027t. I really, really tried everything I could to avoid doing this, but there is one inescapable problem.\nFor PCIe, we have multiprocess support enabled. This means that the ctrlr struct and the admin qpair are allocated out of shared memory and can be accessed from multiple processes. If I store the transport struct in the controller, the function pointers will be invalid for all of the secondary processes.\nLuckily, the I/O qpairs are not shared between processes so we can store a transport struct in those. I have the check on lines 295-297 to avoid the call to nvme_get_transport in the I/O path.",
      "parentUuid": "afe4a9b5_a9f82cee",
      "range": {
        "startLine": 299,
        "startChar": 13,
        "endLine": 299,
        "endChar": 61
      },
      "revId": "e649a2149d4cef87cbc6f6623f0a8e0055507123",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6832cb76_9b5eb91f",
        "filename": "lib/nvme/nvme_transport.c",
        "patchSetId": 20
      },
      "lineNbr": 299,
      "author": {
        "id": 1011222
      },
      "writtenOn": "2020-01-14T22:20:08Z",
      "side": 1,
      "message": "Yeah - I brought up this same concern with Seth offline.  It really is unavoidable.  Note that we only call nvme_get_transport() here for admin queue, so it doesn\u0027t really run in the I/O path.\n\nA possible optimization I thought of would be to store the transport in the controller, which is the ops structure for the *primary* process.  Then we only use the ctrlr-\u003etransport object if spdk_process_is_primary() \u003d\u003d true.  spdk_process_is_primary() resolves to a DPDK function that just returns a valid from a global structure (much cheaper than the string compares).",
      "parentUuid": "73158e34_b5269da7",
      "range": {
        "startLine": 299,
        "startChar": 13,
        "endLine": 299,
        "endChar": 61
      },
      "revId": "e649a2149d4cef87cbc6f6623f0a8e0055507123",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}