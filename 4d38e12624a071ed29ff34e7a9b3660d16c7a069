{
  "comments": [
    {
      "key": {
        "uuid": "887bc2a5_3b1fdd23",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-03-01T21:05:51Z",
      "side": 1,
      "message": "Ah, I see we can allocate an io_channel via hotplug event after this poller has finished, but before spdk_vhost_scsi_stop has unset vsession-\u003elcore. Would it make the problem go away if we unset vsession-\u003elcore right here?",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ffa60ed_dbe31354",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-03-04T09:36:54Z",
      "side": 1,
      "message": "The main issue is that the spdk_vhost_session_send_event() is unlocking mutex. This is opening a slot for RPC thread to issue eg add or remove target request while this poller is still running (vsession-\u003etask_cnt \u003e 0).\n\nFrom others side: I removed unlocking part from spdk_vhost_session_send_event() to give it a try and hit deadlock :/",
      "parentUuid": "887bc2a5_3b1fdd23",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55d5457f_ad1720a1",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-03-04T15:33:29Z",
      "side": 1,
      "message": "\u003e The main issue is that the spdk_vhost_session_send_event() is unlocking mutex. This is opening a slot for RPC thread to issue eg add or remove target request while this poller is still running (vsession-\u003etask_cnt \u003e 0).\n\nThis shouldn\u0027t cause any trouble. The session is perfectly usable until we start freeing its io_channels. Can you shed some more light on the actual problem here?",
      "parentUuid": "1ffa60ed_dbe31354",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7de8dd5a_471ec165",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-03-05T07:18:00Z",
      "side": 1,
      "message": "When you send events to session using foreach_session() it might be \"perfectly usable\" but when you wake up in this add/remove target event handler the session might be already dead because stop handler just got executed. In JSON RPC reactor thread you don\u0027t know  if session isn\u0027t stopping from DPDK thread, aren\u0027t you?\n\nThis why you need to mark it as stopping before releasing mutex in spdk_vhost_session_send_event().",
      "parentUuid": "55d5457f_ad1720a1",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4761e2dc_fc505391",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-03-05T08:47:57Z",
      "side": 1,
      "message": "But foreach_session() iteration (for a particular session) and the session\u0027s stop poller run on the same thread. There can\u0027t be a data race between those two. At the time the stop poller runs, the DPDK thread is waiting on a semaphore doing nothing.",
      "parentUuid": "7de8dd5a_471ec165",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e875ab28_7950634f",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-03-05T15:08:22Z",
      "side": 1,
      "message": "yes, but RPC add/remove call on other thread (reactor) might get called then as big vhost lock is relesed while  DPDK is waiting on semaphore.",
      "parentUuid": "4761e2dc_fc505391",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c11e0f97_95041f05",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-03-05T18:43:57Z",
      "side": 1,
      "message": "Please describe the exact problem. Does something crash here, is it a deadlock, ..?",
      "parentUuid": "e875ab28_7950634f",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96b3829c_886fd3a0",
        "filename": "lib/vhost/vhost_scsi.c",
        "patchSetId": 1
      },
      "lineNbr": 1365,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-03-06T08:23:53Z",
      "side": 1,
      "message": "Yes it is crashing and described here https://github.com/spdk/spdk/issues/687",
      "parentUuid": "c11e0f97_95041f05",
      "revId": "4d38e12624a071ed29ff34e7a9b3660d16c7a069",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}