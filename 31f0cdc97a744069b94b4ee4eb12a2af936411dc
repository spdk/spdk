{
  "comments": [
    {
      "key": {
        "uuid": "633c1c42_5f9c4034",
        "filename": "lib/nvmf/nvmf.c",
        "patchSetId": 2
      },
      "lineNbr": 511,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2018-10-11T21:08:55Z",
      "side": 1,
      "message": "What if the user specifically set the global target options? Shouldn\u0027t that take precedence over default options of any type?",
      "revId": "31f0cdc97a744069b94b4ee4eb12a2af936411dc",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51579275_57164505",
        "filename": "lib/nvmf/nvmf.c",
        "patchSetId": 2
      },
      "lineNbr": 511,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2018-10-11T23:36:10Z",
      "side": 1,
      "message": "How would we tell if the target opts had been set by the user? The only way I know how to do that is through the RPC. That just calls the generic opts init function and then changes some of the variables in the returned opts structure behind the scenes. We would have to do an explicit comparison between the tgt_opts and the default macros.\n\nWould there be anything wrong with just deprecating target opts entirely? It seems like keeping this structure could create more problems than it solves, especially as we scale up with the number of transports we support. Overloading a transport default with a custom target value could be dangerous/unwanted behavior.\nA specific example of this might be io_unit_size. This value may have different implications between TCP and RDMA in RDMA it is closely linked to the dma safe buffers we allocate to store data for transport between the two NICs. I don\u0027t know exactly what this value would mean to TCP, but it probably won\u0027t be that (just guessing here). If that number is significantly larger for TCP, overriding it in the tgt opts could cause us to run out of memory in an RDMA transport that adopts those target options (Not that anybody would necessarily run both transports in the same app, but it is a possibility).",
      "parentUuid": "633c1c42_5f9c4034",
      "revId": "31f0cdc97a744069b94b4ee4eb12a2af936411dc",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73057a6_ebfbfdfb",
        "filename": "lib/nvmf/nvmf.c",
        "patchSetId": 2
      },
      "lineNbr": 512,
      "author": {
        "id": 1014365
      },
      "writtenOn": "2018-10-11T22:33:27Z",
      "side": 1,
      "message": "The transport \"opts_init\" function is used similarly to the spdk_nvmf_tgt_opts_init() function.  It\u0027s supposed to set the default values for those that aren\u0027t being set by the user (app). Also, the changes I made here were to provide backward compatibility with exiting apps. that still use the \"add listener\" functionality to create a transport.  However, this functionality should be deprecated and eventually removed in favor of using spdk_nvmf_transport_create() to create the transport.",
      "revId": "31f0cdc97a744069b94b4ee4eb12a2af936411dc",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}