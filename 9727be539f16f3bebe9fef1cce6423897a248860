{
  "comments": [
    {
      "key": {
        "uuid": "d3037f9c_86535843",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 270,
      "author": {
        "id": 1011207
      },
      "writtenOn": "2017-12-18T12:47:25Z",
      "side": 1,
      "message": "This still can be overflow as double is 64bit and original return uint64_t is also 64bit. In the case that two 64bit multiply, the result may be overflow.\n\nMy fix is to do the \"/\" calculation first instead of doing \"*\".\n\nI\u0027ve also added an example in my patch.",
      "range": {
        "startLine": 270,
        "startChar": 37,
        "endLine": 270,
        "endChar": 86
      },
      "revId": "9727be539f16f3bebe9fef1cce6423897a248860",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8ddf978_d1629072",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 270,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2017-12-18T18:27:03Z",
      "side": 1,
      "message": "change this to \n\n(spdk_get_ticks_hz() / 1000000ULL) * period_microseconds;\n\nand you avoid averflow for reasonable range of period_microseconds",
      "parentUuid": "d3037f9c_86535843",
      "range": {
        "startLine": 270,
        "startChar": 37,
        "endLine": 270,
        "endChar": 86
      },
      "revId": "9727be539f16f3bebe9fef1cce6423897a248860",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7326daa6_02709bc2",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 270,
      "author": {
        "id": 1011275
      },
      "writtenOn": "2017-12-19T01:17:01Z",
      "side": 1,
      "message": "I do not agree. How can you make sure this is an integer. If the value is not integrate after /, the precision will be an issue. For example,  if the value is 222.9, and you get 222 (just an example), and the precision will not be correct",
      "parentUuid": "f8ddf978_d1629072",
      "range": {
        "startLine": 270,
        "startChar": 37,
        "endLine": 270,
        "endChar": 86
      },
      "revId": "9727be539f16f3bebe9fef1cce6423897a248860",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "338a96e5_ed6f4c96",
        "filename": "lib/event/reactor.c",
        "patchSetId": 3
      },
      "lineNbr": 270,
      "author": {
        "id": 1011275
      },
      "writtenOn": "2017-12-19T01:19:20Z",
      "side": 1,
      "message": "use / first will also lose precision. Suppose the value passed is 20 us. then you will get 0. I think that the reason why Daniel use * first is to make sure the precision, but he did not consider the overflow due to large value ipput",
      "parentUuid": "d3037f9c_86535843",
      "range": {
        "startLine": 270,
        "startChar": 37,
        "endLine": 270,
        "endChar": 86
      },
      "revId": "9727be539f16f3bebe9fef1cce6423897a248860",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}