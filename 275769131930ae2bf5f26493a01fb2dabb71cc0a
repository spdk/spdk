{
  "comments": [
    {
      "key": {
        "uuid": "9b47a12d_576ed49a",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 273,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "Call this \u0027md_buf\u0027 - we typically just use \u0027md\u0027 everywhere so for searching consistency it\u0027s nice to follow that.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0bae652_f85a2f6d",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 273,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9b47a12d_576ed49a",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3062371_a23d3127",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 493,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "Same here - md",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecbc2600_210b20c9",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 493,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d3062371_a23d3127",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e6189c3e_1b388846",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1863,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "This line (1864) actually remains common between the two cases",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62a120ac_4e6095d4",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1863,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "I noticed that, but I set the data field in both cases since its value is checked by the caller of spdk_nvmf_rdma_request_parse_sgl to determine if memory buffer has been allocated for that request. In the case of enabled dif_insert_or_strip we can assign value to this field once we get md_buf.\nIt is possible to move the assignment after if/else block, but we\u0027ll have to reference `rdma_req-\u003erecv-\u003ebuf + offset` on line 1902 instead of data pointer",
      "parentUuid": "e6189c3e_1b388846",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c73ee835_2403b7c1",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1868,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "const doesn\u0027t mean anything to compilers in C typically (because in every scenario it can either automatically figure out if the value ever changes, or it can\u0027t and has to assume someone casts the const away somewhere). It\u0027s only useful as a communication tool between developers in an API. I\u0027d recommend just removing it here.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cb9bdbf_68df811d",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1868,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Ok, I just thought it would make it easier to read the code",
      "parentUuid": "c73ee835_2403b7c1",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf253c8b_e449133d",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1869,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "This division and the mod below are not great for performance in the I/O path. Check out spdk_u32_is_pow2 and our use of that elsewhere - since we happen to know that length is usually a power of 2 we can often use bit shifts instead.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ba280c4_fa5f0c37",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1869,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Thanks, I added bit shift instead of division",
      "parentUuid": "bf253c8b_e449133d",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d04e1283_994b27c0",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1878,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "The length has already been checked against max_len, so presumably this can\u0027t ever happen here because the md_buf pool is allocated to handle a valid in capsule data size.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf4b670_fa1b72a6",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1878,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "I removed this condition",
      "parentUuid": "d04e1283_994b27c0",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "68ab78f6_a8e61277",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1883,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-09-17T18:26:31Z",
      "side": 1,
      "message": "Same with this - the in capsule data side is negotiated (and is already confirmed less than or equal to the max allowed), so it must pass this check. You can maybe make this an assert instead.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f8c2f33_62d380f4",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1883,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "68ab78f6_a8e61277",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c3c19981_9cdb70f2",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1901,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2019-09-18T05:42:12Z",
      "side": 1,
      "message": "Can you point to me how this works for in-capsule data, if there is a 4KiB data, the IOV should be like this:\n\n512 bytes data \niov.[0]\n16 bytes metadata\niov.[1]\n.\n.\n.\nafter calling spdk_dif_generate(), the backend NVMe driver can\u0027t accept such data buffers with extended LBA format.",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1e6c801_ee9797a5",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1901,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-09-18T13:27:01Z",
      "side": 1,
      "message": "Do you mean that the controller expects a full extended LBA to be pointed by a single iov entry? I checked the spec and didn\u0027t find any statements that the SGL entry should be a multiple of the block size.\nIn the case of read/write operation with this feature enabled there may be a case when iov(SGL) entry points to a part of the data block and this works fine (at least with Intel and Samsung disks)\nPlease correct me if I misunderstood your comment",
      "parentUuid": "c3c19981_9cdb70f2",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c294436_f9bcd3a5",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1901,
      "author": {
        "id": 1011204
      },
      "writtenOn": "2019-09-20T02:16:54Z",
      "side": 1,
      "message": "For the SGL entries like above, if the physical NVMe device can support SGL feature, it may work, I didn\u0027t test that before, but it can\u0027t work with PRP only NVMe drives. Can you point me which Intel SSDs you are using? I may do a test offline. Thanks.",
      "parentUuid": "a1e6c801_ee9797a5",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "963a12c9_b20c7c6d",
        "filename": "lib/nvmf/rdma.c",
        "patchSetId": 15
      },
      "lineNbr": 1901,
      "author": {
        "id": 1012251
      },
      "writtenOn": "2019-09-20T02:30:24Z",
      "side": 1,
      "message": "Hi Changpeng,\n\nDIF insert/strip for SPDK iSCSI target didn\u0027t work with PRP NVMe-SSDs. Intel P3700 didn\u0027t support SGL and so I used WD (HGST) NVMe-SSD which supports SGL.\n\nI heard Intel Optane NVMe-SSD supports SGL and have one but formatting of it doesn\u0027t work for some reason. I haven\u0027t investigated why formatting failed though.\n\nEugene added virtual DIF to NULL bdev and so we can test even if we don\u0027t have NVMe-SSD which supports SGL.\n\n-Shuhei",
      "parentUuid": "8c294436_f9bcd3a5",
      "revId": "275769131930ae2bf5f26493a01fb2dabb71cc0a",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}