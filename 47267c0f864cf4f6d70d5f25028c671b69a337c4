{
  "comments": [
    {
      "key": {
        "uuid": "ec8b1346_881f9267",
        "filename": "lib/util/string.c",
        "patchSetId": 12
      },
      "lineNbr": 109,
      "author": {
        "id": 1010531
      },
      "writtenOn": "2019-01-05T04:27:12Z",
      "side": 1,
      "message": "I actually think there is a trick here to make this much simpler. From the man page for vsnprintf:\n\nThe functions snprintf() and vsnprintf() do not write more than size bytes (including the terminating null byte (\u0027\\0\u0027)). If the output was truncated due to this limit then the return value is the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. Thus, a return value of size or more means that the output was truncated. (See also below under NOTES.)\n\nSo here\u0027s the trick - start the function by attempting the vsnprintf on the original buffer. It will then return the required size. Then just realloc the buffer to the returned size (plus one) one time and redo the vsnprintf. That eliminates a lot of the tricky parts of what to do if the second or third realloc fails.",
      "revId": "47267c0f864cf4f6d70d5f25028c671b69a337c4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4db26ef4_6b70e6ed",
        "filename": "lib/util/string.c",
        "patchSetId": 12
      },
      "lineNbr": 109,
      "author": {
        "id": 1012251
      },
      "writtenOn": "2019-01-07T00:03:20Z",
      "side": 1,
      "message": "Thank you for providing so nice idea!\nI used vsnprintf(NULL, 0, format, args_copy) + orig_size + 1 because this is safe for me.",
      "parentUuid": "ec8b1346_881f9267",
      "revId": "47267c0f864cf4f6d70d5f25028c671b69a337c4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da8fb183_75fa87b2",
        "filename": "lib/util/string.c",
        "patchSetId": 12
      },
      "lineNbr": 139,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-02T12:40:08Z",
      "side": 1,
      "message": "I can\u0027t see it clarified anywhere - why do we free the buffer on error?\n\nThis could be troublesome:\n\n```\nint update_some_object(void *obj, int id) {\n   obj-\u003ename \u003d spdk_vsprintf_realloc(obj-\u003ename, \"MyObject%d\", id);\n   if (obj-\u003ename \u003d\u003d NULL) {\n      // what do we do with the entire obj now?\n      return -1; // failed to update\n   }\n}\n```\n\nIf the obj-\u003ename can\u0027t be updated and the original value is gone, then how am I supposed to implement error handling?\nI can make a copy of obj-\u003ename before calling spdk_vsprintf_realloc, but that\u0027s not very handy.",
      "revId": "47267c0f864cf4f6d70d5f25028c671b69a337c4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f0bf4a2_780911cd",
        "filename": "lib/util/string.c",
        "patchSetId": 12
      },
      "lineNbr": 139,
      "author": {
        "id": 1011230
      },
      "writtenOn": "2019-01-02T14:10:49Z",
      "side": 1,
      "message": "look into the while loop. If first realloc pass and second fail buffer will be freed anyway by first realloc() call.",
      "parentUuid": "da8fb183_75fa87b2",
      "revId": "47267c0f864cf4f6d70d5f25028c671b69a337c4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}