{
  "comments": [
    {
      "key": {
        "uuid": "c4139dcd_a6ef5b29",
        "filename": "lib/nvme/nvme_rdma.c",
        "patchSetId": 2
      },
      "lineNbr": 1923,
      "author": {
        "id": 1016482
      },
      "writtenOn": "2019-10-28T15:00:22Z",
      "side": 1,
      "message": "Maybe we can introduce a common function that will lock the mutex if it is not locked?",
      "range": {
        "startLine": 1919,
        "startChar": 0,
        "endLine": 1923,
        "endChar": 2
      },
      "revId": "bebe2f65f97db87c40f9ba374211b0d0c741f64e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99d846be_f3209928",
        "filename": "lib/nvme/nvme_rdma.c",
        "patchSetId": 2
      },
      "lineNbr": 1923,
      "author": {
        "id": 1011223
      },
      "writtenOn": "2019-10-28T16:44:39Z",
      "side": 1,
      "message": "That\u0027s a good idea. My long term thoughts for this are to create a separate mutex for the qpair itself. I think using the controller mutex to protect qpair variables isn\u0027t the best solution. It just sort of evolved out of the fact that the global controller state and the global qpair state have historically changed at roughly the same time.\nI also think that there is a lot of code that assumes that a mutex is in a specific state within the transport specific code for both TCP and RDMA which I think makes the code pretty fragile from a maintenance perspective.\nI was thinking I want to remove those assumptions and either change the mutexes to be recursive so that they can be taken multiple times on the same thread, or find some other way to allow us to be more explicit about when/why we take a lock.\nI just added this simple change for the time being so that we could fix a github issue before the release without rocking the boat too much.",
      "parentUuid": "c4139dcd_a6ef5b29",
      "range": {
        "startLine": 1919,
        "startChar": 0,
        "endLine": 1923,
        "endChar": 2
      },
      "revId": "bebe2f65f97db87c40f9ba374211b0d0c741f64e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    }
  ]
}