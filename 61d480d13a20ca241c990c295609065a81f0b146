{
  "comments": [
    {
      "key": {
        "uuid": "e15f80bd_f4fc0962",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 101,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "What happens to the cached I/O that hasn\u0027t been written to the core disk yet? Does this function block until all data is written, does it do some work asynchronously, or does it exit with an error? Could we have some comments here?",
      "range": {
        "startLine": 101,
        "startChar": 6,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b6034ee_341178fc",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 101,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "This function blocks until all OCF requests completed (our pollers run them)\nIs that ok?\nI, will write comment, ack.",
      "parentUuid": "e15f80bd_f4fc0962",
      "range": {
        "startLine": 101,
        "startChar": 6,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75d32365_36b8e2e0",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 101,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-22T20:53:39Z",
      "side": 1,
      "message": "What if there\u0027s an io_channel on the same thread that\u0027s now blocked? The I/O poller won\u0027t have a chance to run and we\u0027ll have a deadlock. Is that correct?",
      "parentUuid": "0b6034ee_341178fc",
      "range": {
        "startLine": 101,
        "startChar": 6,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82f1778a_4d146d29",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 135,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "you should keep the claimed state in the base struct. The bdev-\u003einternal mustn\u0027t be accessed by anything but bdev.c",
      "range": {
        "startLine": 135,
        "startChar": 17,
        "endLine": 135,
        "endChar": 25
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf143d33_b53cad19",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 135,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "Ack\nThis check was unnecessary since bdev-\u003eattached is sufficient, I will just remove it",
      "parentUuid": "82f1778a_4d146d29",
      "range": {
        "startLine": 135,
        "startChar": 17,
        "endLine": 135,
        "endChar": 25
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea34efd7_a765e10d",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 178,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "There might be still some active io_channels with their pollers running in the background, which still reference this cas vbdev. In most cases, those io_channels will have an already pending asynchronous removals, but you still have to wait for those to actually finish, otherwise you risk having io_channel pollers to access freed memory.\n\nThe second argument in spdk_io_device_unregister is a callback to be called after all io channels are put, and only after it\u0027s called you should be able to free the vbdev resources.\n\nI\u0027d suggest doing something like that:\n\n```\nif (vbdev-\u003estate.started) {\n  stop_vbdev(vbdev);\n  spdk_io_device_unregister(vbdev, _cas_vbdev_stop_cb);\n} else {\n  // io_device not registered, free vbdev resources directly\n  _cas_vbdev_stop_cb(vbdev);\n}\n```\n\nThis brings me to the next question - why do we check pending I/O for all the queues here? (line #164) Do we expect I/O pollers to be still running or is it just a fail-safe that prevents us from crashing?",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5847711b_994fbea0",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 178,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "I will make this call synchronous since current OCF cachin gmodes (WT and PT) do not require clean up\nWould that be ok?\n\nIf I free resources in spdk_bdev_unregister callback, would that be ok? Since bdev unregister calls io device unregister during spdk_bdev_fini\n\nWhy we check for pending io - that was unnecessary having PT and WT only",
      "parentUuid": "ea34efd7_a765e10d",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8fd0f4a_f8da1516",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 629,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "Is this assert necessary? ocf_cache_get_queue an external function after all and we don\u0027t know under what circumstances it could possibly fail.",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "958e7d7d_f1f2af8a",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 629,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "Ack\nI was using internal knowleage about this function xd",
      "parentUuid": "d8fd0f4a_f8da1516",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5482aff1_773ea49c",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 652,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "Is there any reason for delaying this removal? The ctx_buf memory is freed by the io_channel lib right after this callback is called, so the qctx poller will operate on already freed memory.\n\nThis callback is run of the same thread that polls the queue, so you\u0027re free to release any qctx resources here directly - including stopping the poller.",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d01173ff_59f7ba02",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 652,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "No, there is no reason to do that now.\nI will clean up everything immediately in this callback, ok?",
      "parentUuid": "5482aff1_773ea49c",
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57c7e768_38efd28c",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 690,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "what\u0027s the need for this macro? Could you use \u0026cache_if directly?",
      "range": {
        "startLine": 690,
        "startChar": 26,
        "endLine": 690,
        "endChar": 46
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2316c0c6_9eba5a1b",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 690,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "57c7e768_38efd28c",
      "range": {
        "startLine": 690,
        "startChar": 26,
        "endLine": 690,
        "endChar": 46
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "205cefa6_895ddfd3",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 972,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "CAS bdev?",
      "range": {
        "startLine": 972,
        "startChar": 18,
        "endLine": 972,
        "endChar": 29
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16c8677b_90b56e1e",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 972,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "205cefa6_895ddfd3",
      "range": {
        "startLine": 972,
        "startChar": 18,
        "endLine": 972,
        "endChar": 29
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97dcdb08_63bce847",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 976,
      "author": {
        "id": 1011218
      },
      "writtenOn": "2019-01-21T06:26:36Z",
      "side": 1,
      "message": "^",
      "range": {
        "startLine": 976,
        "startChar": 18,
        "endLine": 976,
        "endChar": 29
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90a30934_39a0bf3f",
        "filename": "lib/bdev/cas/vbdev_cas.c",
        "patchSetId": 58
      },
      "lineNbr": 976,
      "author": {
        "id": 1014935
      },
      "writtenOn": "2019-01-21T13:27:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "97dcdb08_63bce847",
      "range": {
        "startLine": 976,
        "startChar": 18,
        "endLine": 976,
        "endChar": 29
      },
      "revId": "61d480d13a20ca241c990c295609065a81f0b146",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}